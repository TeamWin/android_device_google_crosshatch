/*
 * Copyright (c) 2015-2017 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 *
 * 2015-16 Qualcomm Atheros, Inc.
 *
 * All Rights Reserved.
 * Qualcomm Atheros Confidential and Proprietary.
 */

/*
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Copyright (c) 2011 The FreeBSD Foundation
 * All rights reserved.
 * Portions of this software were developed by David Chisnall
 * under sponsorship from the FreeBSD Foundation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 2014-2015 The Linux Foundation. All rights reserved.
 *
 * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
 *
 *
 * Permission to use, copy, modify, and/or distribute this software for
 * any purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * This file was originally distributed by Qualcomm Atheros, Inc.
 * under proprietary terms before Copyright ownership was assigned
 * to the Linux Foundation.
 */

#include <stdlib.h>
#ifdef CNSS_DIAG_PLATFORM_WIN
#include <limits.h>
#endif
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include "cld-diag-parser.h"
#ifdef CNSS_DIAG_PLATFORM_WIN
#include <time.h>
#include <syslog.h>
#else
#include <sys/time.h>
#endif
#ifdef ANDROID
#include "time_genoff.h"
#endif
#ifdef CONFIG_CLD80211_LIB
extern struct cld80211_ctx *cldctx;
#endif

typedef struct diag_entry {
	uint32_t id;
	boolean isUsed;

	/* database - userspace */
	char *format;
	char *pack;

	/* runtime message - generated by target */
	char *msg;
	uint32_t msg_len;
}diag_entry;

typedef struct file_header {
	int32_t  file_version;
	int32_t  n_entries;
	int32_t  n_usedEntries;
	int32_t  hash;
}file_header;

static diag_entry *gdiag_db[NUM_OF_DRIVERS] = {0};
static file_header *gdiag_header[NUM_OF_DRIVERS] = {0};
static int32_t gisdiag_init[NUM_OF_DRIVERS] = {0};
static int gdiag_sock_fd = 0, goptionflag = 0;
extern int avail_space;
extern int log_path_flag;
extern int free_mem_threshold;
static uint64_t base_timestamp = 0;
extern unsigned int configured_buffer_size;
extern int max_no_buffer;
extern uint8_t gwlan_dev;
extern uint32_t max_pktlog_buff_size;
extern struct cnss_log_file_data log_file[LOG_FILE_MAX];
extern char wlan_log_dir_path[MAX_FILENAME_SIZE];
extern char *log_file_name_prefix[LOG_FILE_MAX];
extern char *log_file_name_extn[LOG_FILE_MAX];
extern int max_pktlog_archives;

/*
 * Flags used during conversion.
 */
#define ALT         0x001		/* alternate form */
#define LADJUST     0x004		/* left adjustment */
#define LONGDBL     0x008		/* long double */
#define LONGINT     0x010		/* long integer */
#define LLONGINT    0x020		/* long long integer */
#define SHORTINT    0x040		/* short integer */
#define ZEROPAD     0x080		/* zero (as opposed to blank) pad */
#define FPT         0x100		/* Floating point number */
#define GROUPING    0x200		/* use grouping ("'" flag) */
                                /* C99 additional size modifiers: */
#define SIZET       0x400		/* size_t */
#define PTRDIFFT    0x800		/* ptrdiff_t */
#define INTMAXT     0x1000		/* intmax_t */
#define CHARINT     0x2000		/* print char using int format */

/*
 * macros to safely extract 8, 16, 32, or 64-bit values from byte buffer
 */
#define GET_8(v, msg, msg_len) do {         \
	if (msg_len < sizeof(uint8_t)) {    \
		goto msg_error;             \
	}                                   \
	v = *msg;                           \
	msg += sizeof(uint8_t);             \
	msg_len -= sizeof(uint8_t);         \
} while (0)

#define _GET_LE16(a) ( \
	(((uint16_t)(a)[1]) << 8) | \
	 ((uint16_t)(a)[0]))
#define GET_LE16(v, msg, msg_len) do {      \
	if (msg_len < sizeof(uint16_t)) {   \
		goto msg_error;             \
	}                                   \
	v = _GET_LE16(msg);                 \
	msg += sizeof(uint16_t);            \
	msg_len -= sizeof(uint16_t);        \
} while (0)

#define _GET_LE32(a) ( \
	(((uint32_t)(a)[3]) << 24) | \
	(((uint32_t)(a)[2]) << 16) | \
	(((uint32_t)(a)[1]) << 8)  | \
	((uint32_t)(a)[0]))
#define GET_LE32(v, msg, msg_len) do {      \
	if (msg_len < sizeof(uint32_t)) {   \
		goto msg_error;             \
	}                                   \
	v = _GET_LE32(msg);                 \
	msg += sizeof(uint32_t);            \
	msg_len -= sizeof(uint32_t);        \
} while (0)

#define _GET_LE64(a) ( \
	(((uint64_t)(a)[7]) << 56) | \
	(((uint64_t)(a)[6]) << 48) | \
	(((uint64_t)(a)[5]) << 40) | \
	(((uint64_t)(a)[4]) << 32) | \
	(((uint64_t)(a)[3]) << 24) | \
	(((uint64_t)(a)[2]) << 16) | \
	(((uint64_t)(a)[1]) << 8) | \
	((uint64_t)(a)[0]))
#define GET_LE64(v, msg, msg_len) do {      \
	if (msg_len < sizeof(uint64_t)) {   \
		goto msg_error;             \
	}                                   \
	v = _GET_LE64(msg);                 \
	msg += sizeof(uint64_t);            \
	msg_len -= sizeof(uint64_t);        \
} while (0)

/*
 * pack_printf derived from Rome FW's cmnos_vprintf which
 * internally is using the FreeBSD version implementation.
 */

/*
 * Macros for converting digits to letters and vice versa
 */
#define to_digit(c)	((c) - '0')
#define is_digit(c)	((unsigned)to_digit(c) <= 9)
#define to_char(n)	((n) + '0')

/*
 * Macro for validating integer range
 */
#define RANGE(i, min, max) (i < min || i > max) ? 1 : 0

#ifdef CNSS_DIAG_PLATFORM_WIN

/*
 * 'strlcpy()' - Safely copy two strings.
 */
size_t
strlcpy(char *dst, const char *src, size_t size)
{
	size_t    srclen;
	size --;

	srclen = strlen(src);

	if (srclen > size)
		srclen = size;

	memcpy(dst, src, srclen);
	dst[srclen] = '\0';

	return (srclen);
}

#endif

/*
 * Convert an unsigned long to ASCII for printf purposes, returning
 * a pointer to the first character of the string representation.
 * Octal numbers can be forced to have a leading zero; hex numbers
 * use the given digits.
 */
static char *
__ultoa(unsigned long long val, char *endp, int base, int octzero,
        const char *xdigs)
{
	char *cp = endp;

	if (endp == NULL || xdigs == NULL) {
		debug_printf("%s: Input parameter invalid", __func__);
		return endp;
	}

	/*
	 * Handle the three cases separately, in the hope of getting
	 * better/faster code.
	 */
	switch (base) {
	case 10:
		if (val < 10) {	/* many numbers are 1 digit */
			*--cp = to_char(val);
			return (cp);
		}
		do {
			*--cp = to_char(val % 10);
			val /= 10;
		} while (val != 0);
		break;

	case 8:
		do {
			*--cp = to_char(val & 7);
			val >>= 3;
		} while (val);
		if (octzero && *cp != '0')
			*--cp = '0';
		break;

	case 16:
		do {
			*--cp = xdigs[val & 15];
			val >>= 4;
		} while (val);
		break;

	case 2:
		do {
			*--cp = to_char(val & 1);
			val >>= 1;
		} while (val);
		break;
	default:			/* oops */
		break;
	}
	return (cp);
}

/* Return successive characters in a format string. */
char fmt_next_char(const char **fmtptr)
{
	char ch;

	ch = **fmtptr;
	if (ch != '\0') {
		(*fmtptr)++;
	}
	return ch;
}

/* Return current characters in a format string. */
char fmt_cur_char(const char **fmtptr)
{
	char ch;
	ch = **fmtptr;
	return ch;
}

long long get_value_from_msg(char pack, uint8_t **msg, uint32_t *msg_len)
{
	switch (pack) {
	case 'b':
	{
		signed char val = 0;
		GET_8(val, *msg, *msg_len);
		return val;
	}
	case 'B':
	{
		unsigned char val = 0;
		GET_8(val, *msg, *msg_len);
		return val;
	}
	case 'h':
	{
		int16_t val = 0;
		GET_LE16(val, *msg, *msg_len);
		return val;
	}
	case 'H':
	{
		uint16_t val = 0;
		GET_LE16(val, *msg, *msg_len);
		return val;
	}
	case 'i':
	{
		int32_t val = 0;
		GET_LE32(val, *msg, *msg_len);
		return val;
	}
	case 'I':
	{
		uint32_t val = 0;
		GET_LE32(val, *msg, *msg_len);
		return val;
	}
	case 'q':
	{
		int64_t val = 0;
		GET_LE64(val, *msg, *msg_len);
		return val;
	}
	case 'Q':
	{
		uint64_t val = 0;
		GET_LE64(val, *msg, *msg_len);
		return val;
	}
	default:
		return 0;
	}
msg_error:
		return 0;
}

/*
 * The size of the buffer we use as scratch space for integer
 * conversions, among other things.  We need enough space to
 * write a uintmax_t in octal (plus one byte).
 */
#define	BUF	(sizeof(long long)*8)

static int
pack_printf(
    void (*write_char)(char **pbs, char *be, char c),
    char **pbuf_start,
    char *buf_end,
    const char *fmt0,
    const char *pack,
    uint8_t *msg,
    uint32_t msg_len)
{
	const char *fmt;     /* format string */
	int ch;              /* character from fmt */
	int n;               /* handy integer (short term usage) */
	char *cp;            /* handy char pointer (short term usage) */
	int flags;           /* flags as above */
	int ret;             /* return value accumulator */
	int width;           /* width from format (%8d), or 0 */
	int prec;            /* precision from format; <0 for N/A */
	char sign;           /* sign prefix (' ', '+', '-', or \0) */

	long long ulval;     /* integer arguments %[diouxX] */
	int base;            /* base for [diouxX] conversion */
	int dprec;           /* a copy of prec if [diouxX], 0 otherwise */
	int realsz;          /* field size expanded by dprec, sign, etc */
	int size;            /* size of converted field or string */
	int prsize;          /* max size of printed field */
	const char *xdigs;   /* digits for %[xX] conversion */
	char buf[BUF];       /* buffer with space for digits of uintmax_t */
	char ox[2];          /* space for 0x; ox[1] is either x, X, or \0 */
	int pad;             /* pad */

	static const char xdigs_lower[16] = "0123456789abcdef";
	static const char xdigs_upper[16] = "0123456789ABCDEF";

	fmt = (char *)fmt0;
	ret = 0;
	size = 0;
	xdigs = xdigs_lower;

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
		for (cp = (char *)fmt; (ch = fmt_cur_char(&fmt)) != '\0' && ch != '%';
			 ch = fmt_next_char(&fmt)){
			write_char(pbuf_start, buf_end, ch);
			ret++;
		}

		if (ch == '\0')
			goto done;
		fmt_next_char(&fmt);		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
		ox[1] = '\0';

rflag:		ch = fmt_next_char(&fmt);
reswitch:	switch (ch) {
		case ' ':
			/*-
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
				sign = ' ';
			goto rflag;
		case '-':
			flags |= LADJUST;
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			ch = fmt_next_char(&fmt);
			prec = 0;
			while (is_digit(ch)) {
				prec = 10 * prec + to_digit(ch);
				ch = fmt_next_char(&fmt);
			}
			goto reswitch;
		case '0':
			/*-
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit(ch);
				ch = fmt_next_char(&fmt);
			} while (is_digit(ch));
			width = n;
			goto reswitch;
		case 'l':
			if (flags & LONGINT) {
				flags &= ~LONGINT;
				flags |= LLONGINT;
			} else
				flags |= LONGINT;
			goto rflag;
		case 'C':
			flags |= LONGINT; /* Do not support WCHAR */
			/*FALLTHROUGH*/
		case 'c':
			if (msg_len) {
				cp = (char *)msg++;
				msg_len--;
				size = 1;
				sign = '\0';
			}
			break;
		case 'D':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			ulval = get_value_from_msg(fmt_next_char(&pack), &msg, &msg_len);
			if (ulval < 0) {
				ulval = -ulval;
				sign = '-';
			}
			base = 10;
			goto number;
		case 'p':
			/*-
			 * ``The argument shall be a pointer to void.  The
			 * value of the pointer is converted to a sequence
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			ulval = (int)get_value_from_msg(fmt_next_char(&pack), &msg,
							&msg_len);
			base = 16;
			xdigs = xdigs_lower;
			ox[1] = 'x';
			goto nosign;
		case 'S':
		case 's':
			/* Not Supported */
			cp = "<null>";
			size = 0;
			while (cp[size] != '\0') size++;
			sign = '\0';
			break;
		case 'O':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			ulval = get_value_from_msg(fmt_next_char(&pack), &msg,
							&msg_len);
			base = 8;
			goto nosign;
		case 'B':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'b':
			ulval = get_value_from_msg(fmt_next_char(&pack), &msg,
							&msg_len);
			base = 2;
			goto nosign;
		case 'U':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			ulval = get_value_from_msg(fmt_next_char(&pack), &msg,
							&msg_len);
			base = 10;
			goto nosign;
		case 'X':
			xdigs = xdigs_upper;
			goto hex;
		case 'x':
			xdigs = xdigs_lower;
hex:

			ulval = get_value_from_msg(fmt_next_char(&pack), &msg,
							&msg_len);
			base = 16;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && ulval != 0)
				ox[1] = ch;

			/* unsigned conversions */
nosign:			sign = '\0';
			/*-
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
					flags &= ~ZEROPAD;

			/*-
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 *
			 * ``The C Standard is clear enough as is.  The call
			 * printf("%#.0o", 0) should print 0.''
			 *	-- Defect Report #151
			 */
			cp = buf + BUF;
			if (ulval != 0 || prec != 0 ||
			    (flags & ALT && base == 8)){
				cp = __ultoa(ulval, cp, base,
				    flags & ALT, xdigs);
			}
			size = buf + BUF - cp;

			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
		}

		/*
		 * All reasonable formats wind up here.  At this point, `cp'
		 * points to a string which (if not flags&LADJUST) should be
		 * padded out to `width' places.  If flags&ZEROPAD, it should
		 * first be prefixed by any sign or other prefix; otherwise,
		 * it should be blank padded before the prefix is emitted.
		 * After any left-hand padding and prefixing, emit zeroes
		 * required by a decimal [diouxX] precision, then print the
		 * string proper, then emit zeroes required by any leftover
		 * floating precision; finally, if LADJUST, pad with blanks.
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
		if (sign)
			realsz++;
		if (ox[1])
			realsz += 2;

		prsize = width > realsz ? width : realsz;
		pad =  width - realsz;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0){
			while(pad-- > 0){
				write_char(pbuf_start, buf_end, ' ');
			}
		}

		/* prefix */
		if (sign){
			write_char(pbuf_start, buf_end, sign);
			pad--;
		}

		if (ox[1]) {	/* ox[1] is either x, X, or \0 */
			ox[0] = '0';
			write_char(pbuf_start, buf_end, ox[0]);
			pad--;
			write_char(pbuf_start, buf_end, ox[1]);
			pad--;
		}

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD){
			while(pad-- > 0){
				write_char(pbuf_start, buf_end, '0');
			}
		}

		while (size-- > 0) {
			ch = *cp++;
			(*write_char)(pbuf_start, buf_end, ch);
		}

		/* left-adjusting padding (always blank) */
		if (flags & LADJUST){
			while(pad-- > 0){
				write_char(pbuf_start, buf_end, ' ');
			}
		}

		/* finally, adjust ret */
		ret += prsize;
	}
done:

	return (ret);
	/* NOTREACHED */
}

static void
format_pack( const char *pack,  char *buf, uint32_t buflen)
{
	char c;
	uint32_t num = 0, index = 0, i = 0;
	boolean isfound = 0;
	memset(buf, 0 , buflen);
	while ((c = fmt_next_char(&pack)) != '\0') {
		if (index >= buflen -1)
			break;
		while (is_digit(c)) {
			num = (i++ * 10) + (c - '0');
			c = fmt_next_char(&pack);
			isfound = TRUE;
		}
		if (isfound) {
			while (num--) {
				buf[index++] = c;
				if (index >= buflen -1)
					break;
			}
			num = 0;
			i = 0;
		}
		else
			buf[index++] = c;
	}
	buf[index] = '\0';
}

void appendLocalTime(char* tmbuf) {
	time_t now;
	struct tm *qtm;
	struct timeval tv;
	char buf[TIME_DATA_SIZE];

	gettimeofday(&tv, NULL);
	now = tv.tv_sec;
	qtm = localtime(&now);
	if ((qtm) && (tmbuf != NULL)) {
		strftime(buf, sizeof(buf), "%H:%M:%S", qtm);
		snprintf(tmbuf, 20, "%s.%06d ", buf, (int)tv.tv_usec);
	}
}

void cnss_write_buf_logs(int log_len, char *log, enum fileType type)
{

	int ret = 0;
	struct cnss_log_file_data *lfd;

	if (type >= LOG_FILE_MAX)
		return;
	lfd = &log_file[type];
	if (!lfd->fp)
		return;
	if ((avail_space  < free_mem_threshold) &&
			(log_path_flag == WRITE_TO_INTERNAL_SDCARD)) {
		android_printf("Device free memory is insufficient");
		return;
	}
	if (lfd->free_buf_mem <= log_len) {
		ret = fwrite(lfd->buf, sizeof(char), (lfd->buf_ptr - lfd->buf), lfd->fp);
		if (ftell(lfd->fp) >= max_file_size) {
			fflush(lfd->fp);
			fclose(lfd->fp);
			backup_file(type);
			if (type == HOST_LOG_FILE ||
						type == FW_LOG_FILE) {
				cnss_open_log_file(TRUE, type);
				lfd->wrap_cnt++;
				fprintf(lfd->fp, "[INFO]:File Wrapped for %d times\n",
						lfd->wrap_cnt);
			}
		}
		lfd->free_buf_mem = configured_buffer_size;
		lfd->buf_ptr = lfd->buf;
		memset(lfd->buf_ptr, 0, lfd->free_buf_mem);
	}
	memcpy(lfd->buf_ptr, log, log_len);
	lfd->buf_ptr += log_len;
	lfd->free_buf_mem -= log_len;
}

/* Allocate buffer to save text logs to QXDM / APEX container log packet format
 * to local file or diag module.
 */
void *cnss_diag_buf_alloc(uint8_t log_source)
{
#ifdef ANDROID
	time_genoff_info_type   genoff;
#else
	struct timespec t;
#endif
	struct cnss_log_pkt_buf *log_pkt_buf;
#ifndef NO_DIAG_SUPPORT
	struct cnss_diag_log_buf *diag_buf;
#endif
	struct cnss_diag_file_buf *diag_file_buf;

	if (optionflag & LOGFILE_QXDM_FLAG) {
		// Local buffer for file
		diag_file_buf = malloc(CNSS_DIAG_LOG_BUF_MAX +
					sizeof (struct cnss_diag_file_buf));
		if (!diag_file_buf)
			return NULL;
		memset(diag_file_buf, 0, CNSS_DIAG_LOG_BUF_MAX +
					sizeof (struct cnss_diag_file_buf));
		diag_file_buf->start_marker = 0x7E;
		diag_file_buf->version = 1;
		diag_file_buf->chunk_length = 0;
		diag_file_buf->std_hdr.cmd_code = 0x10;
		diag_file_buf->std_hdr.more = 0;
		diag_file_buf->std_hdr.len1 = sizeof(struct
				cnss_diag_std_file_buf_hdr_log_pkt_hdr);
		diag_file_buf->std_hdr.len2 = sizeof(struct
				cnss_diag_std_file_buf_hdr_log_pkt_hdr);
		diag_file_buf->std_hdr.log_pkt_hdr.log_code = CNSS_DIAG_LOG_ID;
		diag_file_buf->std_hdr.log_pkt_hdr.ts = 0;
		log_pkt_buf = (struct cnss_log_pkt_buf *)diag_file_buf->log_packet;
	} else {
#ifndef NO_DIAG_SUPPORT
		// Diag module buffer alloc API
		diag_buf = log_alloc(CNSS_DIAG_LOG_ID, CNSS_DIAG_LOG_BUF_MAX);
		if(!diag_buf)
			return NULL;
		memset(diag_buf, 0, CNSS_DIAG_LOG_BUF_MAX);
		log_pkt_buf = &diag_buf->log_pkt_buf;
#endif
	}
	log_pkt_buf->hdr.version = 1;
	log_pkt_buf->hdr.source = log_source;
	log_pkt_buf->hdr.type = LOG_TYPE_F3_STRING;
	log_pkt_buf->hdr.num_ent = 0;

#ifdef ANDROID
	genoff.base = ATS_MODEM;
	genoff.unit = TIME_MSEC;
	genoff.operation = T_GET;
	genoff.ts_val = &log_pkt_buf->hdr.time_stamp;
	if (time_genoff_operation(&genoff))
		log_pkt_buf->hdr.time_stamp = 0;
#else
	clock_gettime(CLOCK_MONOTONIC, &t);
	// sec->msec + nsec->msec conversion
	log_pkt_buf->hdr.time_stamp = ((unsigned long long)t.tv_sec * 1000) +
				((unsigned long long)t.tv_nsec / 1000000);
#endif
	// Diag Standard: Convert to 1.25 ms and shift << 16
	log_pkt_buf->hdr.time_stamp =
			((log_pkt_buf->hdr.time_stamp / 4ll) * 5ll) << 16;
	if (optionflag & LOGFILE_QXDM_FLAG)
		return diag_file_buf;
#ifndef NO_DIAG_SUPPORT
	else
		return diag_buf;
#endif
}

/* Commit container log packet to file buffer or directly to DIAG Module */
void cnss_diag_log_commit(void *buf, int flag, uint8_t log_source)
{
	struct cnss_log_pkt_buf *log_pkt_buf;
	struct cnss_diag_file_buf *diag_file_buf = NULL;
	int tot_file_buf_chunk_len;

	if (flag ==  LOGFILE_QXDM_FLAG) {
		diag_file_buf = buf;
                debug_printf("DIAG FILE Buf Data:\n%x Ver: %d Len: %d CC: %d More: %d len1: %d len2: %d LC: %d TS: %"PRIu64"\n",
                        diag_file_buf->start_marker,
                        diag_file_buf->version,
                        diag_file_buf->chunk_length,
                        diag_file_buf->std_hdr.cmd_code,
                        diag_file_buf->std_hdr.more,
                        diag_file_buf->std_hdr.len1,
                        diag_file_buf->std_hdr.len2,
                        diag_file_buf->std_hdr.log_pkt_hdr.log_code,
                        diag_file_buf->std_hdr.log_pkt_hdr.ts);

		log_pkt_buf = (struct cnss_log_pkt_buf *)diag_file_buf->log_packet;
                debug_printf("Log chunk Buf Data:\nVer: %d SRC: %d Type: %d Num_ent: %d TS: %"PRIu64"\n",
                        log_pkt_buf->hdr.version,
                        log_pkt_buf->hdr.source,
                        log_pkt_buf->hdr.type,
                        log_pkt_buf->hdr.num_ent,
                        log_pkt_buf->hdr.time_stamp);

		// Set end marker
		*((uint8_t *)(((uint8_t *) log_pkt_buf) + diag_file_buf->chunk_length)) = 0x7E;
		tot_file_buf_chunk_len = diag_file_buf->chunk_length +
					sizeof(struct cnss_diag_file_buf);
		diag_file_buf->std_hdr.len1 += diag_file_buf->chunk_length;
		diag_file_buf->std_hdr.len2 += diag_file_buf->chunk_length;
		diag_file_buf->chunk_length +=
				sizeof(struct cnss_diag_std_file_buf_hdr);
		// Save to file
		if (log_source == LOG_SOURCE_HOST)
			cnss_write_buf_logs(tot_file_buf_chunk_len,
				(char *)diag_file_buf, HOST_QXDM_LOG_FILE);
		else
			cnss_write_buf_logs(tot_file_buf_chunk_len,
				(char *)diag_file_buf, FW_QXDM_LOG_FILE);
	} else {
#ifndef NO_DIAG_SUPPORT
		// Commit to Diag module
		log_commit(buf);
#endif
	}
}

void cnss_diag_log_entry_cur_time(uint8_t log_source, uint64_t *cur_time)
{
	// Following qcacld-3.0 Helium and Napier use Qtimer Stamp for HOST and FW
	if (gwlan_dev == CNSS_DIAG_WLAN_DEV_UNDEF) {
		*cur_time = 0;
	} else if (gwlan_dev == CNSS_DIAG_WLAN_HEL_DEV &&
				 gwlan_dev == CNSS_DIAG_WLAN_NAP_DEV) {
#ifndef CNSS_DIAG_PLATFORM_WIN
#if __aarch64__
		asm volatile("mrs %0, cntpct_el0" : "=r" (cur_time));
#else
		asm volatile("mrrc p15, 0, %Q0, %R0, c14" : "=r" (cur_time));
#endif
#endif
		*cur_time /= QTIMER_FREQ_KHZ;
	} else {
		// Following qcacld-3.0 Rome / Tuf uses Kernel boot time Stamp
		// for FW sync and timeofday for HOST logs to correlate with User space.
		if (log_source == LOG_SOURCE_HOST) {
			struct timeval tv;
			struct tm *day_time;
			gettimeofday(&tv, NULL);
			day_time = localtime((time_t *)&tv.tv_sec);
			*cur_time = ((day_time->tm_hour * 3600 + day_time->tm_min * 60 +
				day_time->tm_sec) * 1000) + (tv.tv_usec / 1000);
		} else {
			struct timespec t;
			clock_gettime(CLOCK_MONOTONIC, &t);
			// sec->msec + nsec->msec conversion
			*cur_time = ((unsigned long long)t.tv_sec * 1000) +
				((unsigned long long)t.tv_nsec / 1000000);
		}
	}
}

void cnss_diag_log_entry_create(struct cnss_log_ent *log, char *log_txt_buf,
				uint8_t log_source, uint64_t cur_time)
{
	int log_txt_len, hh, mm, ss, ts_us;
	uint64_t log_time = 0;
	char *ts_ptr;

	log_txt_len = strlen(log_txt_buf) + 1;
	log->txt_len = log_txt_len;
	if (gwlan_dev == CNSS_DIAG_WLAN_DEV_UNDEF) {
		log->delta_time = 0;
	} else {
		ts_ptr = log_txt_buf;
		if (log_source == LOG_SOURCE_HOST) {
			// Get Time stamp. Parse format as given from wlan driver
			while (!(*ts_ptr == ']')) {
				if (*ts_ptr == '\0') {
					// Handle empty lines and multi line logs
					if (log->txt_len == 1)
						return;
					else
						goto skip_multi_ln_log_time;
				}
				ts_ptr++;
			}
			if (gwlan_dev == CNSS_DIAG_WLAN_ROM_DEV ||
				 gwlan_dev == CNSS_DIAG_WLAN_TUF_DEV) {
				sscanf(++ts_ptr, "[%02d:%02d:%02d.%06d",
						 &hh, &mm, &ss, &ts_us);
				if (RANGE(hh, INT_MIN, INT_MAX) ||
				    RANGE(mm, INT_MIN, INT_MAX) ||
				    RANGE(ss, INT_MIN, INT_MAX) ||
				    RANGE(ts_us, INT_MIN, INT_MAX)) {
					printf("Error in parsing time");
					return;
				}
				log_time = ((hh * 3600 + mm * 60 + ss) * 1000) +
							(ts_us / 1000);
			} else {
				sscanf(++ts_ptr, "[%"PRIu64"]", &log_time);
				if (RANGE(log_time, 0, ULONG_MAX)) {
					printf("Error in parsing time");
					return;
				}
				// Conv to milli sec
				log_time /= QTIMER_FREQ_KHZ;
			}
		} else {
			ts_ptr = strstr(log_txt_buf, "FWMSG");
			// Shift by 7 chars to move to Time stamp value ie "FWMSG: [%llu]"
			if (ts_ptr) {
				ts_ptr += strlen("FWMSG: ");
				sscanf(ts_ptr, "[%"PRIu64"]", &log_time);
				if (RANGE(log_time, 0, ULONG_MAX)) {
					printf("Error in parsing time");
					return;
				}
			}
		}
skip_multi_ln_log_time:
		log->delta_time = log_time - cur_time;
	}
#ifndef NO_DIAG_SUPPORT
	log->lvl = MSG_LEGACY_MED;
	if (log_source == LOG_SOURCE_HOST)
		log->ss_id = MSG_SSID_WLAN_RESERVED_10;
	else
		log->ss_id = MSG_SSID_WLAN;
#endif
	memcpy(log->txt, log_txt_buf, log_txt_len);
}

/* Convert WLAN text logs to containder log packet format for QXDM / APEX */
void cnss_conv_diag_log_packet(uint8_t log_source, char *orig_wlan_log_buf,
		uint32_t wlan_log_buf_len, int flag)
{
	struct cnss_log_pkt_buf *log_pkt_buf;
	struct cnss_diag_log_buf *diag_buf = NULL;
	struct cnss_diag_file_buf *diag_file_buf = NULL;
	int log_txt_len;
	uint64_t cur_time;
	char *wlan_log_buf, *wlan_log_buf_start, *wlan_log_buf_end,
		 *wlan_log_buf_ptr, *log_pkt_buf_ptr;

	wlan_log_buf_start = malloc(wlan_log_buf_len);
	if (!wlan_log_buf_start) {
		printf("Log buf copy failed\n");
		return;
	}
	wlan_log_buf = wlan_log_buf_start;
	memcpy(wlan_log_buf, orig_wlan_log_buf, wlan_log_buf_len);
	wlan_log_buf_end = wlan_log_buf + wlan_log_buf_len;
	wlan_log_buf_ptr = wlan_log_buf;

	if (flag == LOGFILE_QXDM_FLAG) {
		diag_file_buf = cnss_diag_buf_alloc(log_source);
		if (!diag_file_buf) {
			printf("log_alloc failed");
			goto err;
		}
		log_pkt_buf = (struct cnss_log_pkt_buf *)diag_file_buf->log_packet;
		diag_file_buf->chunk_length += sizeof(struct cnss_log_pkt_hdr);
	} else {
		diag_buf = cnss_diag_buf_alloc(log_source);
		if (!diag_buf) {
			printf("log_alloc failed");
			goto err;
		}
		log_pkt_buf = &diag_buf->log_pkt_buf;
	}
	cnss_diag_log_entry_cur_time(log_source, &cur_time);

	log_pkt_buf_ptr = (char *)log_pkt_buf + sizeof(struct cnss_log_pkt_hdr);

	while (wlan_log_buf_ptr < wlan_log_buf_end) {
		while ((*wlan_log_buf_ptr != '\n') &&
					(*wlan_log_buf_ptr != '\0') &&
					(wlan_log_buf_ptr <
					wlan_log_buf_end)) {
			++wlan_log_buf_ptr;
		}
		*wlan_log_buf_ptr++ = '\0';
		log_txt_len = strlen(wlan_log_buf) + 1;
		if (log_txt_len == 1) {
			wlan_log_buf = wlan_log_buf_ptr;
			continue;
		}
		// Check if adding next log_ent overflows max 6K and send log buffer to diag
		if (((log_pkt_buf_ptr - (char *)log_pkt_buf) +
				sizeof(struct cnss_log_ent) +
				log_txt_len) >= (CNSS_DIAG_LOG_BUF_MAX)) {
			if (flag == LOGFILE_QXDM_FLAG) {
				cnss_diag_log_commit(diag_file_buf, flag,
							log_source);
				memset(log_pkt_buf, 0, CNSS_DIAG_LOG_BUF_MAX);
				log_pkt_buf = (struct cnss_log_pkt_buf *)
						diag_file_buf->log_packet;
				log_pkt_buf->hdr.num_ent = 0;
			} else {
				cnss_diag_log_commit(diag_buf, flag, log_source);
				diag_buf = cnss_diag_buf_alloc(log_source);
				if (!diag_buf) {
					printf("log_alloc failed");
					goto err;
				}
				log_pkt_buf = &diag_buf->log_pkt_buf;
			}
		}
		cnss_diag_log_entry_create((struct cnss_log_ent *) log_pkt_buf_ptr,
					wlan_log_buf, log_source, cur_time);
		log_pkt_buf_ptr = log_pkt_buf_ptr +
				sizeof(struct cnss_log_ent) + log_txt_len;
		if (flag == LOGFILE_QXDM_FLAG) {
			diag_file_buf->chunk_length +=
					sizeof(struct cnss_log_ent) +
					log_txt_len;
		}
		log_pkt_buf->hdr.num_ent++;
		wlan_log_buf = wlan_log_buf_ptr;
	}
	if (flag == LOGFILE_QXDM_FLAG) {
		cnss_diag_log_commit(diag_file_buf, flag, log_source);
		free(diag_file_buf);
	} else {
		cnss_diag_log_commit(diag_buf, flag, log_source);
	}
err:
	if (wlan_log_buf_start)
		free(wlan_log_buf_start);
}

void buffer_fw_logs_log_pkt(char *fw_log, boolean force)
{
	static char *fw_buf, *fw_buf_ptr;
	static int free_buf_mem;
	int log_len;
#define FW_LOG_COLLECTION_BUF_SIZE 4096
	// One time alloc during first logging.
	if (!fw_buf) {
		fw_buf = malloc(FW_LOG_COLLECTION_BUF_SIZE);
		if (!fw_buf)
			return;
		fw_buf_ptr = fw_buf;
		free_buf_mem = FW_LOG_COLLECTION_BUF_SIZE;
	}
	log_len = strlen(fw_log);

	if (free_buf_mem < log_len || force) {
		cnss_conv_diag_log_packet(LOG_SOURCE_FW, fw_buf,
				(fw_buf_ptr - fw_buf), LOGFILE_QXDM_FLAG);
		fw_buf_ptr = fw_buf;
		free_buf_mem = FW_LOG_COLLECTION_BUF_SIZE;
		memset(fw_buf_ptr, 0, free_buf_mem);
	}
	memcpy(fw_buf_ptr, fw_log, log_len);
	fw_buf_ptr += log_len;
	free_buf_mem -= log_len;
	if (force) {
		free(fw_buf);
		fw_buf = NULL;
	}
}

static t_buffer *add_new_buff(t_buffer *current, int length)
{
	t_buffer *new_buffer = NULL;

	new_buffer = (t_buffer *) malloc(sizeof(t_buffer));
	if (new_buffer == NULL)
		return NULL;
	memset(new_buffer, 0x00, sizeof(t_buffer));

	new_buffer->start = (unsigned char *) malloc(length);
	if (new_buffer->start == NULL) {
		free(new_buffer);
		return NULL;
	}
	new_buffer->end = new_buffer->start;

	new_buffer->next = current->next;
	current->next = new_buffer;

	return new_buffer;
}

/* Buffers firmware and driver logs */
static void cnss_logs_to_buffer(int bytes_read, char *read_data, enum fileType type)
{
	int available_space;
	struct cnss_log_file_data *lfd;
	t_buffer *buffer_log = NULL;

	if (type >= LOG_FILE_MAX)
		return;
	if ((0 >= bytes_read) || (bytes_read > EACH_BUF_SIZE)) {
		android_printf("Unexpected buffer received %d",bytes_read);
		return;
	}
	lfd = &log_file[type];
	pthread_mutex_lock(&lfd->buff_lock);
	buffer_log = (t_buffer *)lfd->buf_ptr;
	available_space = EACH_BUF_SIZE - (buffer_log->end - buffer_log->start);

	if (bytes_read > available_space) {
		if (lfd->num_buffers_occupied < max_no_buffer) {
			t_buffer *new_buffer;

			new_buffer = add_new_buff(buffer_log, EACH_BUF_SIZE);
			if (new_buffer) {
				lfd->num_buffers_occupied++;
				buffer_log = new_buffer;
			} else {
				/* If malloc fails write into the oldest buf */
				buffer_log = buffer_log->next;
				buffer_log->end = buffer_log->start;
			}
		} else {
			buffer_log = buffer_log->next;
			buffer_log->end = buffer_log->start;
		}
	}

	memcpy(buffer_log->end, read_data, bytes_read);
	buffer_log->end += bytes_read;
	lfd->buf_ptr =(char*) buffer_log;
	pthread_mutex_unlock(&lfd->buff_lock);
}

static int
diag_printf(const char *buf,  uint16_t vdevid,  uint16_t level,
            uint32_t optionflag, uint64_t timestamp, FILE *fp,
            uint32_t radio_id)
{
	char pbuf[MAX_SIZE];
	char pfilebuf[MAX_SIZE];
	int bytes_copied = 0;
	char tmbuf[TIME_DATA_SIZE];
	appendLocalTime(tmbuf);
	if (vdevid < DBGLOG_MAX_VDEVID)
		bytes_copied = snprintf(pbuf, MAX_SIZE, "R%d: FWMSG: [%" PRIu64 "] vap-%u %s", radio_id, timestamp,
								 vdevid, buf);
	else
		bytes_copied = snprintf(pbuf, MAX_SIZE, "R%d: FWMSG: [%" PRIu64 "] %s", radio_id, timestamp, buf);
	if (bytes_copied < 0 || bytes_copied >= MAX_SIZE) {
		android_printf("ERROR: %s failed to write Buffer",__func__);
		return 0;
	}
#ifndef NO_DIAG_SUPPORT
	if (optionflag & QXDM_FLAG) {
		switch(level) {
		case DBGLOG_VERBOSE:
			MSG_SPRINTF_1(MSG_SSID_WLAN, MSG_LEGACY_LOW, "%s",
				      pbuf);
			break;
		case DBGLOG_INFO:
			MSG_SPRINTF_1(MSG_SSID_WLAN, MSG_LEGACY_MED , "%s",
				      pbuf);
			break;
		case DBGLOG_INFO_LVL_1:
			MSG_SPRINTF_1(MSG_SSID_WLAN, MSG_LEGACY_MED , "%s",
				      pbuf);
			break;
		case DBGLOG_INFO_LVL_2:
			MSG_SPRINTF_1(MSG_SSID_WLAN, MSG_LEGACY_MED , "%s",
				      pbuf);
			break;
		case DBGLOG_WARN:
			MSG_SPRINTF_1(MSG_SSID_WLAN, MSG_LEGACY_HIGH, "%s",
				      pbuf);
			break;
		case DBGLOG_ERR:
			MSG_SPRINTF_1(MSG_SSID_WLAN, MSG_LEGACY_HIGH, "%s",
				      pbuf);
			break;
		case DBGLOG_LVL_MAX:
			MSG_SPRINTF_1(MSG_SSID_WLAN, MSG_LEGACY_FATAL, "%s",
				      pbuf);
			break;
		default:
			MSG_SPRINTF_1(MSG_SSID_WLAN, MSG_LEGACY_FATAL, "%s",
				      pbuf);
			break;
		}
	}
#endif
	if (optionflag & CONSOLE_FLAG) {
		android_printf("%s\n", pbuf);
	}
#ifdef CNSS_DIAG_PLATFORM_WIN
	if (optionflag & SYSLOG_FLAG) {
		syslog(LOG_INFO, "%s\n", pbuf);
	}
#endif
	if ((optionflag & LOGFILE_FLAG || optionflag & LOGFILE_QXDM_FLAG) && fp) {
		if (!((optionflag & SILENT_FLAG) ==
		       SILENT_FLAG))
			printf("%ld: %s\n", (fp != NULL) ? ftell(fp): 0, buf);

		bytes_copied = snprintf(pfilebuf, MAX_SIZE, "%s %s\n", tmbuf, pbuf);
		if (bytes_copied < 0 || bytes_copied >= MAX_SIZE) {
			android_printf("ERROR: %s failed to write Buffer",__func__);
			return 0;
		}
		if (optionflag & LOGFILE_QXDM_FLAG)
			buffer_fw_logs_log_pkt(pfilebuf, FALSE);
		if (optionflag & LOGFILE_FLAG)
			cnss_write_buf_logs(bytes_copied, pfilebuf, FW_LOG_FILE);
	}
	if (optionflag & LOG_BUFF_FLAG && optionflag & DECODED_LOG_FLAG) {
		bytes_copied = snprintf(pfilebuf, MAX_SIZE, "%s %s\n", tmbuf, pbuf);
		if (bytes_copied < 0 || bytes_copied >= MAX_SIZE) {
			android_printf("ERROR: %s failed to write Buffer",__func__);
			return 0;
		}
		cnss_logs_to_buffer(bytes_copied, pfilebuf, BUFFER_FW_FILE);
	}
	return 0;
}

/*
 * database initialization
 */
static void
diag_create_db(uint32_t n_entries, uint32_t radio_id)
{
	if (radio_id < NUM_OF_DRIVERS && gdiag_header[radio_id] == NULL) {
		gdiag_header[radio_id] = calloc(1, sizeof(*gdiag_header[radio_id]));
		if (!gdiag_header[radio_id])
			return;
		gdiag_header[radio_id]->n_entries = n_entries;
		gdiag_db[radio_id] = calloc(gdiag_header[radio_id]->n_entries, sizeof(*gdiag_db[radio_id]));
		if (!gdiag_db[radio_id])
			return;
		/* hash */
		gdiag_header[radio_id]->hash = (gdiag_header[radio_id]->n_entries % 2 == 0) ?  \
			gdiag_header[radio_id]->n_entries / 2 :                      \
			(gdiag_header[radio_id]->n_entries + 1) / 2;
	}
}

/*
 * database free
 */
static void
diag_free_db()
{
	int32_t count = 0, radio_id;
	diag_entry *diag_db = NULL;
	file_header *diag_header = NULL;
	int32_t *isdiag_init = NULL;
	for (radio_id = 0; radio_id < NUM_OF_DRIVERS; radio_id++) {
		diag_db = gdiag_db[radio_id];
		diag_header = gdiag_header[radio_id];
		isdiag_init = &gisdiag_init[radio_id];
		if (diag_db && diag_header) {
			for (count = 0; count < diag_header->n_entries; count++) {
				if (diag_db[count].isUsed){
					if (diag_db[count].format)
						free(diag_db[count].format);
					if (diag_db[count].pack)
						free(diag_db[count].pack);
				}
			}
		}
		if (diag_db)
			free(diag_db);
		gdiag_db[radio_id] = NULL;
		if (diag_header)
			free(diag_header);
		gdiag_header[radio_id] = NULL;
		if (isdiag_init)
			*isdiag_init = FALSE;
	}
}

/*
 * insert into database
 */
static int32_t
diag_insert_db(char *format, char *pack, int32_t id, uint32_t radio_id)
{
	file_header *diag_header = NULL;
	diag_entry *diag_db = NULL;

	if (radio_id < NUM_OF_DRIVERS) {
		if (!gdiag_header[radio_id]) {
			android_printf("%s: gdiag_header for radio_id %d is NULL\n",
				__func__, radio_id);
			return 0;
		}
		diag_header = gdiag_header[radio_id];
		diag_db = gdiag_db[radio_id];

		/* Double Hashing  */
		int32_t i = id % diag_header->n_entries;
		int32_t j = diag_header->hash - (id % diag_header->hash);
		if (diag_header->n_entries == diag_header->n_usedEntries) {
			debug_printf("db is full");
			return 0;
		}
		/* search */
		while (diag_db[i].isUsed) {
			i = (i + j)%diag_header->n_entries;
		}

		diag_db[i].id = id;
		diag_db[i].format = format;
		diag_db[i].pack = pack;
		diag_db[i].isUsed = TRUE;
		diag_header->n_usedEntries++;
		return 1;
	} else {
		android_printf("%s: invalid radio_id %d.\n",
			__func__, radio_id);
		return 0;
	}
}

/*
 * parser looks up entry at runtime based on 'id' extracted from FW
 * message
 */
static diag_entry*
diag_find_by_id(uint32_t id, uint32_t radio_id)
{
	boolean isfound = FALSE;
	int32_t count = 0;
	int32_t i;
	int32_t j;
	file_header *diag_header = NULL;
	diag_entry *diag_db = NULL;

	if (radio_id < NUM_OF_DRIVERS) {
		if (!gdiag_header[radio_id]) {
			android_printf("%s: gdiag_header for radio_id %d is NULL\n",
				__func__, radio_id);
			return 0;
		}
		diag_header = gdiag_header[radio_id];
		if (!gdiag_db[radio_id]) {
			android_printf("%s: gdiag_db for radio_id %d is NULL\n",
				__func__, radio_id);
			return 0;
		}
		diag_db = gdiag_db[radio_id];

		i = id % diag_header->n_entries;
		j = diag_header->hash - (id % diag_header->hash);
		if (diag_header->n_usedEntries == 0) {
			return NULL;
		}
		while (diag_db[i].isUsed != 0 && count <= diag_header->n_entries) {
			if (diag_db[i].id == id) {
				isfound = TRUE;
				break;
			}
			i = (i + j) % diag_header->n_entries;
			count++;
		}
		if (!isfound) {
			debug_printf("Not found in data base\n");
			return NULL;
		}
		return &diag_db[i];
	} else {
		android_printf("%s: invalid radio_id %d.\n",
			__func__, radio_id);
		return 0;
	}
}

/* user  supply their own function to build string in temporary
 * buffer
 */
static void dbg_write_char(char **pbuf_start, char *buf_end, char c)
{
	if ( *pbuf_start < buf_end) {
		*(*pbuf_start) = c;
		++(*pbuf_start);
	}
}

static uint32_t
get_numberofentries(int32_t radio_id)
{
	FILE* fd = NULL;
	char line[1024];
	int32_t n_entries = 0, i = 0;
	boolean  isfound = FALSE;

	if (radio_id < NUM_OF_DRIVERS) {
		if (radio_id == 0) {
			if ((fd = fopen(DB_1_FILE_2_PATH, "r")) == NULL &&
				(fd = fopen(DB_1_FILE_1_PATH, "r")) == NULL) {
				diag_printf("[Error] : While opening driver 1 file\n",
				    0, 4, goptionflag, 0, NULL, radio_id);
				return 0;
			}
		} else if (radio_id == 1) {
			if ((fd = fopen(DB_2_FILE_1_PATH, "r")) == NULL) {
				diag_printf("[Error] : While opening driver 2 file\n",
				    0, 4, goptionflag, 0, NULL, radio_id);
				return 0;
			}
		}
		if (fd == NULL) {
			android_printf("%s: fd is NULL\n", __func__);
			return 0;
		}
		while ( fgets (line, sizeof(line), fd) != NULL ) {
			n_entries++;
		}
		/* Decrement 1 for version and the last line /r/n */
		n_entries-= 2;

		/* check if n_entries is prime number else change to prime number */
		while (1) {
			for (i = 2; i<n_entries; i++) {
				if ( n_entries % i == 0 ) {
					/* n_entries is divisible, break for loop */
					isfound = TRUE;
					break;
				}
			}
			if (!isfound && n_entries > 2)
				break;
			isfound = FALSE;
			/* Increment n_entries and check is it prime number */
			n_entries++;
		}
		fclose(fd);
		debug_printf( "Number of entries is %d\n", n_entries);
		return n_entries;
	} else {
		android_printf("%s: invalid radio_id %d.\n",
			__func__, radio_id);
		return 0;
	}
}

static uint32_t
parse_dbfile(uint32_t radio_id)
{
	FILE* fd = NULL;
	uint32_t n_entries = 0;
	uint32_t id = 0;
	char line[1024], *p = NULL, *pack = NULL, *format = NULL;
	char pbuf[128], *q = NULL;
	char *save;
	n_entries = get_numberofentries(radio_id);
	diag_create_db(n_entries, radio_id);
	n_entries = 0;
	file_header *diag_header = NULL;

	if (radio_id >= NUM_OF_DRIVERS) {
		android_printf("%s: invalid radio_id %d.\n",
			__func__, radio_id);
		return 0;
	}

	if (!gdiag_header[radio_id]) {
		android_printf("%s: gdiag_header for radio_id %d is NULL\n",
			__func__, radio_id);
		return 0;
	}
	diag_header = gdiag_header[radio_id];

	/* Open the data.msc file for the correct radio driver */
	if (radio_id == 0) {
		if ((fd = fopen(DB_1_FILE_2_PATH, "r")) == NULL &&
			(fd = fopen(DB_1_FILE_1_PATH, "r")) == NULL) {
			diag_printf("[Error] : While opening driver 1 file\n",
			    0, 4, goptionflag, 0, NULL, radio_id);
			return 0;
		}
	} else if (radio_id == 1) {
		if ((fd = fopen(DB_2_FILE_1_PATH, "r")) == NULL) {
			diag_printf("[Error] : While opening driver 2 file\n",
			    0, 4, goptionflag, 0, NULL, radio_id);
			return 0;
		}
	}
	memset(line, 0 , sizeof(line));
	while ( fgets (line, sizeof(line), fd) != NULL ) {
		n_entries++;
		if (n_entries == 1) {
			/* Parse for the version */
			p = strstr(line, "VERSION:");
			if (p) {
				p += strlen("VERSION:");
				diag_header->file_version = (int32_t)strtol(p, (char **)NULL, 10);
			}
			else {
				fclose(fd);
				return 0;
			}
		} else {
			p = strtok_r(line, ",", &save);
			if (p)
				id = (uint32_t)strtol(p, (char **)NULL, 10);
			else
				continue;

			p = strtok_r(NULL, ",", &save);
			if (p)
				pack = strdup(p);
			else
				continue;

			p = strtok_r(NULL, "\r", &save);
			if (p) {
				format = strdup(p);
				if (format) {
					/* Check for CR */
					p = strstr(format, "\r");
					if (p)
						*p = '\0';
					else {
						p = strstr(format, "\n");
						if (p)
							*p = '\0';
					}
				}
			} else {
				/* Else CASE for pack specifier is 0  */
				if (pack) {
					/* Check for CR */
					p = strstr(pack, "\r");
					if (p)
						*p = '\0';
					else {
						p = strstr(pack, "\n");
						if (p)
							*p = '\0';
					}
					format = pack;
					pack = NULL;
				}
			}
			/* Go through the pack specifier, to find
			   pack with number */
			if (pack) {
				q = pack;
				format_pack(pack, pbuf, sizeof(pbuf));
				pack = strdup(pbuf);
				free(q);
			}
			if (!diag_insert_db(format, pack, id, radio_id)) {
				fclose(fd);
				return 0;
			}
		}
		memset(line, 0 , sizeof(line));
	}
	fclose(fd);
	return n_entries;
}


static int32_t
sendcnss_cmd(int sock_fd, int32_t cmd, int len, uint8_t *buf)
{
	struct dbglog_slot *slot;
	struct sockaddr_nl dest_addr;
	struct nlmsghdr *nlh = NULL;
	struct msghdr msg;
	struct iovec iov;
	int32_t ret, slot_len = 0;

	slot_len =  sizeof(struct dbglog_slot) + len;
	char *slot_buf = NULL;
	slot_buf = malloc(slot_len);
	if (slot_buf == NULL) {
		fprintf(stderr, "Cannot allocate slot memory \n");
		return -1;
	}
	slot = (struct dbglog_slot *)slot_buf;
	memset(slot, 0 , sizeof(struct dbglog_slot));
	slot->diag_type = cmd;
	slot->length = len;
	memcpy(slot->payload, buf, len);

	memset(&dest_addr, 0, sizeof(dest_addr));
	dest_addr.nl_family = AF_NETLINK;
	dest_addr.nl_pid = 0; /* For Linux Kernel */
	dest_addr.nl_groups = 0; /* unicast */

	nlh = malloc(NLMSG_SPACE(slot_len));
	if (nlh == NULL) {
		fprintf(stderr, "Cannot allocate memory \n");
		free(slot_buf);
		return -1;
	}
	memset(nlh, 0, NLMSG_SPACE(slot_len));
	nlh->nlmsg_len = NLMSG_SPACE(slot_len);
	nlh->nlmsg_pid = getpid();
	nlh->nlmsg_type = WLAN_NL_MSG_CNSS_DIAG;
	nlh->nlmsg_flags = NLM_F_REQUEST;

	memcpy(NLMSG_DATA(nlh), slot_buf, slot_len);
	free(slot_buf);

	memset(&msg, 0, sizeof(msg));
	iov.iov_base = (void *)nlh;
	iov.iov_len = nlh->nlmsg_len;
	msg.msg_name = (void *)&dest_addr;
	msg.msg_namelen = sizeof(dest_addr);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

#ifdef CONFIG_CLD80211_LIB
	if (cldctx)
		ret = send_nlmsg(cldctx, WLAN_NL_MSG_CNSS_DIAG,
		                 NLMSG_DATA(nlh), slot_len);
	else
#endif
		ret  = sendmsg(sock_fd, &msg, 0);
	free(nlh);
	return ret;
}


void
diag_initialize(int sock_fd, uint32_t optionflag)
{
	uint32_t ret, radio_id;
	goptionflag = optionflag;

	diag_free_db();
	for (radio_id = 0; radio_id < NUM_OF_DRIVERS; radio_id++) {
		ret = parse_dbfile(radio_id);
		if (ret > 1)
			gisdiag_init[radio_id] = TRUE;
		else
			gisdiag_init[radio_id] = FALSE;
	}
	gdiag_sock_fd = sock_fd;
}

void
process_diaghost_msg(uint8_t *datap, uint16_t len)
{
	uint8_t  *payload;
	UNUSED(len);
	event_report_t *pEvent_report =(event_report_t *)datap ;
	if (!pEvent_report)
		return;
	debug_printf("\n  %s diag_type = %d event_id =%d\n",
		     __func__, pEvent_report->diag_type,
		     pEvent_report->event_id);
	if (pEvent_report->diag_type == DIAG_TYPE_EVENTS) {
		payload = datap + sizeof(event_report_t);
#ifndef NO_DIAG_SUPPORT
		event_report_payload(pEvent_report->event_id,
				     pEvent_report->length, payload);
#endif
	}
}

void
process_diagfw_diagtypeconfig(uint32_t id, char *payload,
							  uint32_t payloadlen)
{
	switch (id) {
	case DIAG_VERSION_INFO:
		/* Not doing anything here since driver has already parsed this */
		debug_printf("%s id=DIAG_VERSION_INFO payloadlen=%d",
					 __func__, payloadlen);
		break;
	case DIAG_BASE_TIMESTAMP:
		base_timestamp = *((uint64_t *)payload);
		debug_printf("%s id=DIAG_BASE_TIMESTAMP payloadlen=%d "
					 "base_timestamp=%" PRIu64,
					 __func__, payloadlen,
					 base_timestamp);
		break;
	default:
		debug_printf("%s unhandled id=%d payloadlen=%d",
					 __func__, id, payloadlen);
		break;
	}
}
uint32_t
process_diagfw_msg(uint8_t *datap, uint16_t len, uint32_t optionflag,
    int32_t version, int sock_fd, uint32_t radio_id)
{
	uint32_t count = 0, index = 0, offset = 0;
	uint64_t timestamp = 0;
	uint32_t diagid = 0, id = 0;
	uint32_t moduleid = 0;
	uint32_t num_buf = 0, payloadlen = 0;
	uint16_t vdevid = 0, vdevlevel = 0;
	uint32_t *buffer;
	uint32_t header1 = 0, header2 = 0;
	char *payload;
	char buf[2*BUF_SIZ], payload_buf[BUF_SIZ];
	char *start = buf;
	int32_t i =0, j =0;
	diag_entry *entry = NULL;
	int ret = 0, total_dump_len = 0;
	uint8_t *debugp = datap;
	char dump_buffer[BUF_SIZ];
	uint32_t read_count = 0;
	file_header *diag_header = NULL;

	if (optionflag & DEBUG_FLAG) {
		memset(dump_buffer, 0, sizeof(dump_buffer));
		debug_printf("process_diagfw_msg hex dump start len %d", len);
		for (i = 0; i < len; i++) {
			ret = snprintf(dump_buffer + j, BUF_SIZ - j,
				       "0x%x ", debugp[i]);
			j += ret;
			if (!(i % 16) && (i!=0)) {
				total_dump_len += 16;
				debug_printf("%s", dump_buffer);
				memset(dump_buffer, 0, sizeof(dump_buffer));
				j = 0;
			}
		}
		if (total_dump_len != len)
			debug_printf("%s", dump_buffer);
		debug_printf("process_diagfw_msg hex dump end");
	}

	if (radio_id >= NUM_OF_DRIVERS) {
		android_printf("%s: invalid radio_id %d.\n",
			__func__, radio_id);
		return 0;
	}

	if (!gisdiag_init[radio_id]) {
		/* If cnss_diag is started if WIFI already ON,
		* then turn on event not received hence
		* before throwing out error initialize again
		*/
		diag_initialize(sock_fd, optionflag);
		if (!gisdiag_init[radio_id]) {
			diag_printf("**ERROR** Diag not initialized for radio/driver",
			    0, 4, optionflag, 0, NULL, radio_id);
			return -1;
		}
	}

	buffer = (uint32_t *)datap;
	buffer ++; /* increment 1 to skip dropped */
	num_buf = len - 4;
	debug_printf("\n --%s-- %d\n", __FUNCTION__, optionflag);

	if (!gdiag_header[radio_id]) {
		android_printf("%s: gdiag_header for radio_id %d is NULL\n",
			__func__, radio_id);
		return 0;
	}
	diag_header = gdiag_header[radio_id];

	while (num_buf  > count) {
		header1 = *(buffer + index);
		diagid  = DIAG_GET_TYPE(header1);
		offset = 1;
		if (diagid > WLAN_DIAG_TYPE_LEGACY_MSG) {
			/*
			   This would mean 64 bit timestamp value to be calculated.
			   Offset of header2 will be one more than the earlier case as
			   there is 32 bit timestamp offset in the next word.
			   Also increment the count by 4.
			*/
			timestamp = (uint64_t)(header1 & DIAG_TIMESTAMP_MASK) << 32;
			timestamp |= (uint32_t)(*(buffer + index + offset));
			offset++;
			count += 4;
		} else {
			timestamp = DIAG_GET_TIME_STAMP(header1);
		}
		timestamp += base_timestamp;
		header2 = *(buffer + offset + index);
		payload = (char *)(buffer + offset + 1 + index);
		/* Incrementing the count by 8 to start of payload */
		count += 8;
		payloadlen = 0;
		debug_printf("diagid = %d  timestamp = %" PRIu64
			     " header1 = %x header2 = %x\n",
			     diagid,  timestamp, header1, header2);
		switch (diagid) {
		case WLAN_DIAG_TYPE_EVENT_V2:
		case WLAN_DIAG_TYPE_EVENT:
		{
			id = DIAG_GET_ID(header2);
			payloadlen = DIAG_GET_PAYLEN16(header2);
			debug_printf("DIAG_TYPE_FW_EVENT: id = %d"
				     " payloadlen = %d \n", id, payloadlen);
#ifndef NO_DIAG_SUPPORT
			if (optionflag & QXDM_FLAG) {
				if (payloadlen)
					event_report_payload(id,
					    payloadlen, payload);
				else
					event_report(id);
			}
#endif
		}
		break;
		case WLAN_DIAG_TYPE_LOG:
		case WLAN_DIAG_TYPE_LOG_V2:
		{
			id = DIAG_GET_ID(header2);
			payloadlen = DIAG_GET_PAYLEN16(header2);
			debug_printf("DIAG_TYPE_FW_LOG: id = %d"
			    " payloadlen = %d \n", id,  payloadlen);
#ifndef NO_DIAG_SUPPORT
			if (optionflag & QXDM_FLAG) {
				/* Allocate a log buffer */
				uint8_t *logbuff = (uint8_t*) log_alloc(id,
				    sizeof(log_hdr_type)+payloadlen);
				if ( logbuff != NULL ) {
					/* Copy the log data */
					memcpy(logbuff + sizeof(log_hdr_type),
					       payload,
					       payloadlen);
					/* Commit the log buffer */
					log_commit(logbuff);
				}
				else
					debug_printf("log_alloc failed"
						     "for len = %d ",
					             payloadlen);
			}
#endif
		}
		break;
		case WLAN_DIAG_TYPE_MSG:
		case WLAN_DIAG_TYPE_MSG_V2:
		{
			id = DIAG_GET_ID(header2);
			payloadlen = DIAG_GET_PAYLEN(header2);
			vdevid = DIAG_GET_VDEVID(header2);
			vdevlevel = DIAG_GET_VDEVLEVEL(header2);
			memset(buf, 0, sizeof(buf));
			memset(payload_buf, 0, BUF_SIZ);
			debug_printf("R%d: DIAG_TYPE_FW_DEBUG_MSG: "
			    " vdevid %d vdevlevel %d payloadlen = %d id = %d\n",
			    radio_id, vdevid, vdevlevel, payloadlen, id);
			if (diag_header->file_version != version) {
				snprintf(buf, BUF_SIZ, "**ERROR**"
				    "R%d: Data.msc Version %d doesn't match"
				    " with Firmware version %d id = %d",
				    radio_id, diag_header->file_version, version, id);
				diag_printf(buf, 0, 4, optionflag, 0, NULL, radio_id);
				break;
			}
			entry = diag_find_by_id(id, radio_id);
			if (entry) {
				if ((payloadlen > 0) && (entry->format && entry->pack)) {
					debug_printf("entry->format = %s"
						     " pack = %s\n",
						     entry->format,
						     entry->pack);
					if (payloadlen < BUF_SIZ)
						memcpy(payload_buf,
						       payload, payloadlen);
					else
						memcpy(payload_buf,
						       payload, BUF_SIZ);
					/* Sending with BUF_SIZ to pack_printf
					 * because some times payloadlen
					 * received doesnt match with the pack
					 * specifier, in that case just print
					 * the zero
					 */
					entry->msg_len = BUF_SIZ;
					entry->msg = payload_buf;
					start = buf;
					pack_printf(
					    dbg_write_char,
					    &start,
					    start + sizeof(buf),
					    entry->format,
					    entry->pack,
					    (uint8_t*)entry->msg,
					    entry->msg_len);
				} else if (entry->format)
					strlcpy(buf, entry->format,
						strlen(entry->format));

				debug_printf("\n buf = %s \n", buf);
				diag_printf(buf, vdevid, vdevlevel, optionflag,
					timestamp, log_file[FW_LOG_FILE].fp,
					radio_id);
			} else {
				switch (id) {
				case DIAG_WLAN_MODULE_STA_PWRSAVE:
				case DIAG_WLAN_MODULE_WAL:
				case DIAG_NAN_MODULE_ID:
				case DIAG_WLAN_MODULE_IBSS_PWRSAVE:
					if (!diag_msg_handler(id, payload,
					        vdevid, timestamp, radio_id)) {
						snprintf(buf, BUF_SIZ,
						    "****WARNING****, undefined"
						    " moduleid = %d not"
						    " found", moduleid);
						diag_printf(buf, 0, 4,
						     optionflag, timestamp,
						     NULL, radio_id);
					}
					break;
				default:
					snprintf(buf, BUF_SIZ,
					    "****WARNING****, FWMSG ID %d"
					    " not found", id);
					diag_printf(buf, 0, 4, optionflag,
					     timestamp, NULL, radio_id);
					printf( "NOT found id = %d\n", id);
				}
			}
		}
		break;
		case WLAN_DIAG_TYPE_CONFIG:
			id = DIAG_GET_ID(header2);
			payloadlen = DIAG_GET_PAYLEN(header2);
			process_diagfw_diagtypeconfig(id, payload, payloadlen);
			break;
		default:
			diag_printf(" ****WARNING**** WRONG DIAG ID", 0,
			    4, optionflag, timestamp, NULL, radio_id);
			return 0;
		}
		count += payloadlen;
		if (optionflag & LOG_BUFF_FLAG &&
		    !(optionflag & DECODED_LOG_FLAG)) {
			cnss_logs_to_buffer(count - read_count,
					    (char *)(buffer + index),
					    BUFFER_FW_FILE);
			read_count = count;
		}
		index = count >> 2;
		debug_printf("Loop end:id = %d  payloadlen = %d"
			     " count = %d index = %d\n",
			     id,  payloadlen,  count, index);
	}

	return (0);
}

/*
WLAN trigger command from QXDM

1) SSR
   send_data 75 41 7 0 1 0 253 len id val1 val 2
   id is subsystem id value
2) log level
   send_data 75 41 7 0 2 0 253 1 25

75 - DIAG_SUBSYS_CMD_F
41 - DIAG_SUBSYS_WLAN
0007 - CNSS_WLAN_DIAG
1 -  CMD type
FC00 - VS Command OpCode

*/
#ifndef NO_DIAG_SUPPORT
void * cnss_wlan_handle(void *req_pkt, uint16_t pkt_len)
{
	void *rsp = NULL;
	uint8_t *pkt_ptr = (uint8_t *)req_pkt + 4;
	uint16_t p_len, p_opcode;
	int32_t ret = 0, i = 0;
	char cmd[BUF_SIZ] = {0};

	/* Allocate the same length as the request
	   */
	rsp = diagpkt_subsys_alloc( DIAG_SUBSYS_WLAN, CNSS_WLAN_DIAG, pkt_len);
	if (rsp != NULL && pkt_len > 3) {
		p_len = *(pkt_ptr+3); /* VS Command packet length */
		p_opcode = (*(pkt_ptr+2) << 8) | *(pkt_ptr+1);
		debug_printf(
		    "%s : p_len: %d, pkt_len -8: %d, p_opcode:%.04x"
		    " cmd = %d\n",
		    __func__, p_len, pkt_len -8, p_opcode,
		    *pkt_ptr);
		if (p_len !=(pkt_len - 8) || ( p_opcode != 0xFD00)) {
			debug_printf("%s:Error in p_len or p_opcode ",
			    __func__);
			return rsp;
		}
		memcpy(rsp, req_pkt, pkt_len);
		if (*pkt_ptr == CNSS_WLAN_SSR_TYPE && p_len > 1) {
			/* get ID */
			i = *(pkt_ptr+4);
			p_len--;
			/* Restart for subsystem id */
			memset(cmd, 0x00, BUF_SIZ);
			snprintf(cmd, sizeof(cmd), RESTART_LEVEL, i);
			debug_printf("%s: cmd = %s\n", __func__, cmd);
			if ((ret = system(cmd))){
				if (ret <  0) {
					debug_printf("%s: error with subsystem"
						     " id\n", __func__);
					return rsp;
				}
			}
			if (gdiag_sock_fd > 0) {
				sendcnss_cmd(gdiag_sock_fd,
				    DIAG_TYPE_CRASH_INJECT,
				    p_len, (pkt_ptr + 5));
				debug_printf("%s: Success with crash inject \n",
				     __func__);
			}
		} else
			debug_printf("%s:Error in Command ", __func__ );
	} else
		debug_printf("%s:Allocate response buffer error", __func__ );
	return rsp;
}
#endif

void printLocalTime(FILE *fp, const char *prefix, const char *suffix)
{
	if (NULL != fp) {
		struct timeval tv;
		time_t now;
		char tmbuf[100];
		struct tm *qtm;
		gettimeofday(&tv, NULL);
		now = tv.tv_sec;
		qtm = localtime(&now);
		if (qtm) {
			if (suffix == NULL || prefix == NULL) {
				strftime(tmbuf, sizeof(tmbuf), "%H:%M:%S", qtm);
				fprintf(fp, "%s.%06d  ", tmbuf, (int)tv.tv_usec);
			} else {
				strftime(tmbuf, sizeof(tmbuf), "%Y-%m-%d %H:%M:%S", qtm);
				fprintf(fp, "%s%s.%06d %s", prefix, tmbuf, (int)tv.tv_usec, suffix);
			}
			if (ftell(fp) >= max_file_size) {
				fflush(fp);
				fclose(fp);
				backup_file(HOST_LOG_FILE);
				cnss_open_log_file(TRUE, HOST_LOG_FILE);
				fclose(fp);
			}
		}
	}
}

/*assumes always length is multiple of 8 */
static void hexDumpPacket(char *p, char *pkt, unsigned int len)
{
	unsigned int i;
	char *_p, *_pkt;

	for (i = 0; i < (len/8); i++) {
		_p = &p[24*i]; _pkt = &pkt[8*i];
		HEXDUMP_PKT8(_p, _pkt);
	}
	return;
}

void process_cnss_host_message(tAniCLDHdr *wnl, int32_t optionflag)
{
	char *wlanLog = (char *)&wnl->wmsg.length + sizeof(wnl->wmsg.length);
	char *charCache = NULL;
	char pktBuf[PKT_BUF_SIZE];
	int i, npkt, bytes;
	unsigned int frameSize;
	int bytes_copied = 0;
	char tmbuf[TIME_DATA_SIZE];
	char pbuf[MAX_SIZE];

	if (!wlanLog)
		return;

	if (wnl->wmsg.type == ANI_NL_MSG_LOG_HOST_MSG_TYPE) {
		char *wend = wlanLog + wnl->wmsg.length;
		charCache = wlanLog;
		if (optionflag & LOGFILE_QXDM_FLAG)
			cnss_conv_diag_log_packet(LOG_SOURCE_HOST, wlanLog,
					wnl->wmsg.length, LOGFILE_QXDM_FLAG);
		if (optionflag & QXDM_SYNC_FLAG)
			cnss_conv_diag_log_packet(LOG_SOURCE_HOST, wlanLog,
					wnl->wmsg.length, QXDM_SYNC_FLAG);

		while (wlanLog < wend) {
			while ((*charCache != '\n') && (*charCache != '\0') &&
				 (charCache < wend)) {
				++charCache;
			}
			*charCache = '\0';
#ifndef NO_DIAG_SUPPORT
			if (optionflag & QXDM_FLAG) {
				WLAN_LOG_TO_DIAG(MSG_SSID_WLAN_RESERVED_10,
					MSG_LEGACY_MED, wlanLog);
			}
#endif
#ifdef CNSS_DIAG_PLATFORM_WIN
			if (optionflag & SYSLOG_FLAG) {
				syslog (LOG_DEBUG, "%s\n", wlanLog);
			}
#endif
			if (optionflag & CONSOLE_FLAG) {
				android_printf("%s\n", wlanLog);
			}
			if (optionflag & LOGFILE_FLAG) {
				if (NULL != log_file[HOST_LOG_FILE].fp) {
					if (!((optionflag & SILENT_FLAG) == SILENT_FLAG))
						printf("%ld: %s\n", ftell(log_file[HOST_LOG_FILE].fp), wlanLog);
					appendLocalTime(tmbuf);
					if (*wlanLog != '\0') {
						bytes_copied = snprintf(pbuf, MAX_SIZE, "%s %s\n", tmbuf, wlanLog);
						if (bytes_copied < 0 || bytes_copied >= MAX_SIZE) {
							android_printf("ERROR: %s failed to write logs",__func__);
						} else {
							cnss_write_buf_logs(bytes_copied, pbuf, HOST_LOG_FILE);
						}
					}
				}
			}
			if (optionflag & LOG_BUFF_FLAG) {
				appendLocalTime(tmbuf);
				if (*wlanLog != '\0') {
					bytes_copied = snprintf(pbuf, MAX_SIZE,
								"%s %s\n",
								tmbuf, wlanLog);
					if (bytes_copied < 0 || bytes_copied >= MAX_SIZE) {
						android_printf("ERROR: %s failed to write logs",__func__);
					} else {
						cnss_logs_to_buffer(bytes_copied,
								    pbuf, BUFFER_HOST_FILE);
					}
				}
			}
			wlanLog = ++charCache;
		}
	} else if(wnl->wmsg.type == ANI_NL_MSG_LOG_MGMT_MSG_TYPE) {
		/* Pkt Message received
		* tAniNlHdr + (uint)frameSize + pkt data
		* The PTT_WLAN_LOG_PKT_MSG message hold 'n' pkts of
		* frameSize bytes each
		*/
		/* Handle management packet logs for pronto */
		frameSize = *(unsigned int *)wlanLog;
		wlanLog += sizeof(frameSize);
		npkt = wnl->wmsg.length / frameSize;

		debug_printf("Received npkt (%d) frameSize (%u)to dump\n",
			npkt, frameSize);
		snprintf(pktBuf, sizeof(pktBuf), "Received npkt (%d) frameSize (%u)"
			" to dump\n", npkt, frameSize);
#ifndef NO_DIAG_SUPPORT
		if (optionflag & QXDM_FLAG)
			WLAN_LOG_TO_DIAG(MSG_SSID_WLAN_RESERVED_10, MSG_LEGACY_MED, pktBuf);
#endif
#ifdef CNSS_DIAG_PLATFORM_WIN
		if (optionflag & SYSLOG_FLAG) {
			syslog (LOG_DEBUG, "%s\n", pktBuf);
		}
#endif
		if (optionflag & LOGFILE_FLAG)
			printLocalTime(log_file[HOST_LOG_FILE].fp, "Debug Pkt Log Time : ", pktBuf);

		for (i = 0; i < npkt; i++) {
			bytes = snprintf(pktBuf, sizeof(pktBuf), "Debug Pkt Dump : ");
			hexDumpPacket(&pktBuf[bytes], wlanLog, frameSize);
#ifndef NO_DIAG_SUPPORT
			if (optionflag & QXDM_FLAG) {
				WLAN_LOG_TO_DIAG(MSG_SSID_WLAN_RESERVED_10,
						MSG_LEGACY_MED, pktBuf);
			}
#endif
#ifdef CNSS_DIAG_PLATFORM_WIN
			if (optionflag & SYSLOG_FLAG) {
				syslog (LOG_DEBUG, "%s\n", pktBuf);
			}
#endif
			if (optionflag & CONSOLE_FLAG)
				android_printf("%s\n", pktBuf);

			if (optionflag & LOGFILE_FLAG) {
				cnss_write_buf_logs(strlen(pktBuf), pktBuf, HOST_LOG_FILE);
				cnss_write_buf_logs(strlen("\n") + 1, "\n", HOST_LOG_FILE);

			}
			wlanLog += frameSize;
		}
	}
}

void process_pronto_firmware_logs(tAniCLDHdr *wnl, int32_t optionflag)
{
	char *wlanLog = (char *)&wnl->wmsg.length + sizeof(wnl->wmsg.length);

	if (!wlanLog)
		return;
	if (optionflag & CONSOLE_FLAG)
		android_printf("%s\n", wlanLog);
	if (optionflag & LOGFILE_FLAG)
		cnss_write_buf_logs(wnl->wmsg.length, wlanLog, FW_LOG_FILE);
	if (optionflag & LOG_BUFF_FLAG && optionflag & DECODED_LOG_FLAG)
		cnss_logs_to_buffer(wnl->wmsg.length, wlanLog, BUFFER_FW_FILE);
}

int capture_pktlog_data(void)
{
	char* PktLogBuffer = NULL;
	FILE* PktFilePtr = NULL;
	struct cnss_log_file_data *lfd;
	int numRecordsRead, numRecordsWritten, readWriteSize, ret = 0;
	uint32_t fileSize = 0, writeSize = 0;

	lfd = &log_file[PKTLOG_FILE];
	if (!lfd->fp) {
		debug_printf("Invalid file descriptor for pktlog file");
		return -1;
	}
	PktLogBuffer = (char*) malloc(sizeof(char) * EACH_CHUNK_SIZE); /* chunk of 256k bytes */
        if (PktLogBuffer == NULL) {
                android_printf("%s: Memory allocating failed for size %d",
				__func__, EACH_CHUNK_SIZE);
                return -1;
	}
	memset(PktLogBuffer, 0, sizeof(char) * EACH_CHUNK_SIZE);

	PktFilePtr = fopen(PKTLOG_FILENAME, "r");
	if (PktFilePtr == NULL) {
                android_printf("Failed to open %s file with error code = %s",
			PKTLOG_FILENAME, strerror(errno));
		free(PktLogBuffer);
		PktLogBuffer = NULL;
                return -1;
        }

	while((numRecordsRead = fread(PktLogBuffer, 1, EACH_CHUNK_SIZE, PktFilePtr)) > 0) {
		readWriteSize = 0;
		fileSize += numRecordsRead;
		if (fileSize > max_pktlog_buff_size) {
			readWriteSize = numRecordsRead - (fileSize - max_pktlog_buff_size);
			fileSize = max_pktlog_buff_size;
		} else {
			readWriteSize = numRecordsRead;
		}

		numRecordsWritten = fwrite(PktLogBuffer, 1, readWriteSize, lfd->fp);
		writeSize += numRecordsWritten;
		if (numRecordsWritten == readWriteSize) {
			debug_printf("Write operation successful for %u bytes", numRecordsWritten);
		} else {
			android_printf("Failed to write data for %u bytes", readWriteSize);
		}
		memset(PktLogBuffer, 0, sizeof(char) * EACH_CHUNK_SIZE);

	}

	if(writeSize == fileSize) {
		android_printf("%s%s%03d.%s:Write operation was done successfully %u",
				wlan_log_dir_path, log_file_name_prefix[PKTLOG_FILE],
				log_file[PKTLOG_FILE].index, log_file_name_extn[PKTLOG_FILE],
				writeSize);
		ret = 0;
	}

	if (feof(PktFilePtr)) {
		debug_printf("File was read successfully for size %u", fileSize);
		ret = 0;
	} else {
		android_printf("Failed to read the pktlog file");
		ret = -1;
	}

	fclose(lfd->fp);
	backup_file(PKTLOG_FILE);
	cnss_open_log_file(TRUE, PKTLOG_FILE);
	fclose(PktFilePtr);
	free(PktLogBuffer);
	PktLogBuffer = NULL;
	return ret;
}

void process_cnss_host_diag_events_log(char *pData, int32_t optionflag)
{
#ifndef NO_DIAG_SUPPORT
	uint32_t diag_type = 0;
	int ret = 0;

	if (pData) {
		diag_type = *(uint32_t*) pData;
		pData += sizeof(uint32_t);
	}
	if (diag_type == DIAG_TYPE_LOGS) {
		log_hdr_type *pHdr = (log_hdr_type*)pData;
		if (log_status(pHdr->code) && (optionflag & QXDM_FLAG)) {
			log_set_timestamp(pHdr);
			log_submit(pHdr);
		}
	} else if (diag_type == DIAG_TYPE_EVENTS) {
		uint16_t event_id;
		uint16_t length;
		wlan_log_complete_event_t *plog_complete;
		event_id = *(uint16_t*)pData;
		pData += sizeof(uint16_t);
		length = *(uint16_t*)pData;
		pData += sizeof(uint16_t);
		if (event_id == EVENT_WLAN_LOG_COMPLETE) {
			plog_complete = (wlan_log_complete_event_t *)pData;
			android_printf("EVENT_WLAN_LOG_COMPLETE event received "
			"Reason code %d\t indicator = %d\t ring_id = %d",
			 plog_complete->reason_code ,plog_complete->indicator,
				 plog_complete->ring_id);
			if ((max_pktlog_archives > 0) &&
			    (plog_complete->indicator == WLAN_LOG_INDICATOR_FRAMEWORK) &&
			    (plog_complete->ring_id == RING_ID_DRIVER_DEBUG)) {

				if (!doesFileExist(log_file[PKTLOG_FILE].name)
					&& log_file[PKTLOG_FILE].fp) {
					if (fclose(log_file[PKTLOG_FILE].fp) == EOF)
						perror("Failed to close pktlog file ");
					log_file[PKTLOG_FILE].index = 0;
					log_file[PKTLOG_FILE].fp = fopen(log_file[PKTLOG_FILE].name, "w");
					if (log_file[PKTLOG_FILE].fp == NULL) {
						android_printf("Failed to create a new pktlog file");
					}
				}
				ret = capture_pktlog_data();
				if (ret < 0)
					android_printf("Failed to capture pktlog");
			}
		}
		if (optionflag & QXDM_FLAG)
			event_report_payload(event_id,length,pData);
	}
#endif
}

